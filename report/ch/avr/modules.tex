\section{AVR Modules}
As the AVR is responsible for performing a lot of tasks, its
functionality is split into a number of more or less independent
modules, each responsible for a specific job or interfacing with a
specific subsystem.

In this section, we will give an overview of the AVR in terms of its
modules, what they do and how they interact. Figure
\ref{fig:avr-modules} shows an overview of some of the more important
modules which we will give a more detailed description of in this section.

\input{fig/avr/modules}

\subsection{Peripherals}
\subsubsection{SD over SPI}
We decided early on to use SD-cards as our main source of data. These
are easy to communicate with, and easy to use framework code that we
could build on already exists.

Even though SD-cards typically support several protocols of
communication, our specific AVR's lack of hardware support for the 4-bit
SD transfer mode left us with SPI as our only choice. While SPI is
simple to use, it is also fairly slow. Our performance issues with SPI
is detailed further in section \ref{sec:avr-spi-issues}.

\subsubsection{FAT}
Managing storage of multiple data sources ourselves on top of a block
device such as SD is tiresome. A file system makes it a lot easier
to manage several data sources simultaneously. For that reason we ended
up adding a FAT filesystem on top of our SD-card, even though it incurs
a performance penalty. \CHECK{are we using FAT, or reading blocks
directly? both?}
\TODO{reference to comparison benchmarks in appendix?}

\subsubsection{FPGA/GPIO}
As explained further in section \ref{sec:avr-fpga-communication}, we
will communicate with the FPGA over a 8/24-bit interface. On the AVR,
GPIO (General Purpose Input/Output) is the subsystem responsible for
reading and writing the pins on this bus.

On top of GPIO, we wrote our code to abstract some of the details of
GPIO, and provide a more natural interface for us to use.\TODO{more on
this?}

\subsubsection{RS232}
RS232 is our protocol of choice for serial communication with a PC. It
was chosen for its simplicity, on both the AVR and PC side. It was never
intended to transfer large amounts of data, but rather be a simple
interface for us to get debugging information out of the AVR.

\subsubsection{SMC/EBI}
The AVR uses a External Bus Interface to connect to external memories,
both SRAM and SDRAM. As our AVR has 512K of SRAM attached, the EBI is
our way of communicating with it.

The SMC (Static Memory Controller) is a part of the EBI that provides us
with a nice, memory-mapped interface to our external SRAM.

\subsection{Utility libraries}
To simplify certain tasks, we have written a number of small utility
libraries to handle small, specific tasks.

\subsubsection{BMP}
In case we want to read standard bitmap-files from SD, we need a way to
extract the raw pixel values from these files and send them in the
correct order to the FPGA (BMP files store images bottom-up, not
top-down). This library takes care of this task.

\subsubsection{Str2Img}
Str2Img is a small text-to-image library that we use to render the menu
the users are presented with when the AVR resets.

\subsubsection{Program}
This is the library responsible for presenting the user with an
interface to select the program to run. It is built on top of other
utility libraries such as Str2Img and our FPGA abstraction layer.

\subsubsection{Buttons}
The user navigates the menu and controls the AVR using buttons. This is
a thin simplification layer built on top of GPIO that handles the
interrupts and button click callbacks. \CHECK{this does not exists as of
right now, but it might in the future :)}

\subsubsection{LEDs}
The main purpose of the LEDs are to tell the user that "something is
happening". These require no abstraction layer of their own, but are
mentioned here because they are used fairly ubiquitously in our code.

\subsection{Programming/Debugging}
\subsubsection{JTAG}
JTAG is the interface we use to connect the AVR to a computer. This
allows us to flash the AVR, debug and profile our programs using
familiar-looking tools: avr32program, avr32-gdb and avr32-gprof,
for flashing, debugging and profiling, respectively.
