\section{AVR Modules}
\input{fig/avr/modules}

The AVR is responsible for controlling the entire system, and has several
important tasks and functionalities related to this. These have been split
into several modules that behave largely independently of eachother.

\begin{table}[htbp]
  \centering
  \begin{tabular}{l|p{10cm}}

% \ac{SD} over \ac{SPI} & We decided early on to use \ac{SD} cards as our main
% source of data. These are easy to communicate with, and easy to use framework
% code that we could build on already exists.  Even though \ac{SD} cards
% typically support several protocols of communication, our specific AVR's lack
% of hardware support for the 4-bit SD transfer mode left us with \ac{SPI} as
% our only choice. While \ac{SPI} is simple to use, it is also fairly slow. Our
% performance issues with \ac{SPI} is detailed further in section
% \ref{sec:avr-spi-issues}. \\

  \ac{SD} over \ac{SPI} & A simple to use source of data/data storage, with easy
  to use framework code available. It's rather slow, however, as the AT32UC3A0
  only has support for \ac{SPI}. [\ref{sec:avr-spi-issues}]. \\ \hline

% \ac{FAT} & Managing storage of multiple data sources ourselves on top of a
% block device such as \ac{SD} is difficult. A file system makes it a lot
% easier to manage several data sources simultaneously. However, it also
% incurs a performance penalty. Therefore we've chosen to implement what is
% not performance critical with \ac{FAT}. \\

  \ac{FAT} & A file system implementation with easy to use framework code
  available. However, using it also incurs a performance penalty and is not used
  in performance critical sections. \\ \hline

% \ac{FPGA}/\ac{GPIO} & As explained further in section
% \ref{sec:avr-fpga-communication}, we will communicate with the \ac{FPGA} over
% a 8/24-bit interface. On the AVR, \ac{GPIO} is the subsystem responsible for
% reading and writing the pins on this bus.  On top of \ac{GPIO}, we wrote our
% code to abstract some of the details of \ac{GPIO}, and provide a more natural
% interface for us to use. \\

  \ac{FPGA}/\ac{GPIO} & Interface for communicating with the \ac{FPGA}. It is
  built on top of \ac{GPIO} and provides a natural interface without low level
  details of \ac{GPIO}. \\ \hline

% RS232 & RS232 is our protocol of choice for serial communication with a PC. It
% was chosen for its simplicity, on both the AVR and PC side. It was never
% intended to transfer large amounts of data, but rather be a simple interface
% for us to get debugging information out of the AVR. \\

  RS232 & A protocol for communication with a PC over the serial port. Very
  simple to use and is very useful for debugging. There was an issue with it,
  however [\ref{sec:avr-serial-issues}] and it is not used past the EVK1100 test
  board. \\ \hline
  
  SMC/EBI & The AVR uses an External Bus Interface to connect to external
  memories, both \ac{SRAM} and \ac{SDRAM}. As our AVR has 512K of \ac{SRAM}
  attached, the \ac{EBI} is our way of communicating with it. The \ac{SMC} is a
  part of the \ac{EBI} that provides us with a nice, memory-mapped interface to
  our external \ac{SRAM}. \\ \hline

% \ac{BMP} & In case we want to read standard bitmap files from \ac{SD}, we need
% a way to extract the raw pixel values from these files and send them in the
% correct order to the \ac{FPGA} (\ac{BMP} files store images bottom-up, not
% top-down). This library takes care of this task. Deprecated since we decided
% to implement the actual image reading as reading raw data without even a file
% system. \\ \hline

  Str2Img & Str2Img is a small text-to-image library that we use to render text
  on the monitor. Primary use is debugging and creating the menu the users are
  presented with when the AVR resets. \\ \hline
  
  Program & This is responsible for presenting the user with an interface to
  select the program to run. It is built on top of other utility libraries such
  as Str2Img and our \ac{FPGA} abstraction layer. \\ \hline

% Button & The user navigates the menu and controls the AVR using buttons. This
% is a thin simplification layer built on top of \ac{GPIO} that handles the
% interrupts and button click callbacks. \CHECK{this does not exists as of right
% now, but it might in the future :)}\\

  \acp{LED} & Functions for turning the \acp{LED} on and off. Useful for
  blinking lights to show information about internal state of the AVR /
  debugging. \\ \hline
  
  \ac{JTAG} & \ac{JTAG} is an interface used to connect the AVR to a
  computer. This allows us to flash the AVR, debug and profile our programs
  using familiar-looking tools: avr32program, avr32-gdb and avr32-gprof, for
  flashing, debugging and profiling, respectively. \\
  \end{tabular}
  \caption{AVR modules}
  \label{tab:asdasd}
\end{table}

%\TODO{FAT: reference to comparison benchmarks in appendix?}
%\TODO{FGPA/GPIO: more?}
%\TODO{Button: predictive writing is never a good idea, that's a surefire way of ending up with outright wrong/contradictive things in our report.}
%\TODO{Program: This isn't really a library then, is it?}
%\TODO{BMP: Should we remove it? It was like a 10 minute job to make and is utterly useless now...} 
%\TODO{SMC/EBI: What? The INTERNAL sram is on the EXTERNAL bus interface? That makes no sense!}
%\TODO{JTAG: what use have we had of avr32-gdb and avr32-gprof? Is use of these described in the report? if not why are we mentioning them?}
