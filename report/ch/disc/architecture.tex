\section {Memory architecture}
\TODO{Graph of memory-architecture} In the early phases of the project,
multiple solutions as to how the data memory should work were suggested. We
decided to let the AVR send all the data to the \ac{FPGA}, and then let it store
them to its own local memory. The reason we chose this over shared memory was
all the potential issues one may get with the shared memory solution. A shared memory
would be prone to errors from synchronization problems such as knowing when,
and to which addresses, a read/write operation should read/write. We figured
that we would rather send all data from the AVR to the \ac{FPGA}, and let it
store them into its own memory as it saw fit.

To allow overlap between loading instructions and data in the LENA
architecture, we chose the Harvard Architecture and used a separate memory for
instructions. The program memory\CHECK{Program memory separated? This is news to me.} is
separated into two chips. The reason for this is mainly that we found no good 24
bit word memory. One solution would be to just buy a 32-bit memory. However, a single 32
bit memory was more expensive than two 16 bit. As both gave us the needed memory,
we went for the cheaper option.

\TODO {find out exactly what was the issue here, with the SD card, frame size,
  and on-chip AVR memory} In addition, we figured a shared \ac{VGA} and data memory would obstruct the flow
of data from the AVR. Since data for the \ac{VGA} would be both read and written
frequently, the \ac{VGA} needed its own memory, rather than sharing memory with
the AVR itself. As we were supposed to optimize for performance, we had to take
possible bottlenecks into consideration. We therefore invested in an extra
memory chip. For the VGA we chose an 8-bit word memory that was big enough to
hold atleast a full screen-frame, at 8-bit per pixel (since each pixel is an 8-bit greyscale pixel).

Lastly, to reduce the possibility of having too slow data-access from the AVR, an extra memory was added to work as
a buffer for the AVR as well. This design choice was made {\em after} ordering, which meant that we had to choose from
the chips we had already ordered to fit this purpose. Since this was intended to carry data intended for the rest
of the system, and as the rest of the system is working with data in 8-bit bytes, we ended up using one of the
extra chips ordered as \ac{VGA} memory for this purpose.

A result of this is that we now had 4 separate memories to allow overlap of
memory accesses. Since the requirements for the data/instruction memories differed in both size and word-width 
we wound up with not only separate, but also different chips for this purpose.



\section{Redundancies}
We had multiple redundancies to avoid potential
errors which would have rendered our whole system unusable. This was recommended
by Jahre, and previous groups had done so as well. In order to send data into
the system, our two main options would be to use the \ac{SD} card or the mini
\ac{USB} plug. We had serial and \ac{JTAG} for debugging purposes. For the
output we had the two \ac{VGA} options. Also, we used headers so as to be able
to alter our pin usage, if need be.\CHECK{What has headers to do with
  redundancy?  It's just convenience.} Luckily, both \ac{SD} card and and our
own \ac{VGA} worked, and we therefore had no need of the
redundancies. \TODO{Motivate the need for the redundancies as well, instead of
  just saying they were unnecessary}
